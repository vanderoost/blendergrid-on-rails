#!/usr/bin/env ruby
require_relative "../config/application"
Rails.application.initialize!

require "curses"
require "set"

LOG_FILE = Rails.root.join("log", "dashboard.log")
DEBUG_LOG = File.open(LOG_FILE, "a")
DEBUG_LOG.sync = true  # Disable buffering
PROJECT_POLL_COUNT = 32
NEW_RENDER_CENTS_THRESHOLD = 5_00

GREEN = 1
BLUE = 2
YELLOW = 3
RED = 4
GRAY = 5

# Log all SQL queries (works in all environments using notifications)
SQL_LOG = File.open(Rails.root.join("log", "dashboard_sql.log"), "a")
SQL_LOG.sync = true

# Subscribe to SQL events - works in all Rails environments
ActiveSupport::Notifications.subscribe("sql.active_record") do |name, start, finish, id, payload|
  unless payload[:name] == "SCHEMA"
    duration = ((finish - start) * 1000).round(1)
    SQL_LOG.puts "#{payload[:name]} (#{duration}ms)  #{payload[:sql]}"
    SQL_LOG.flush
  end
end

# What to store in state?
# VIEWS
#  - Projects Table
#  - Project Details
#  - User Details
#  - Revenue / KPI Stats

class Dashboard
  include Curses

  def initialize
    log("Starting dashboard")

    # TODO: Use a better system for state (state machine?)
    ################ STATE ################
    @view = :home_view
    @data_lock = Mutex.new
    @poll_signal = ConditionVariable.new
    @fetch_error = nil

    @projects = []
    @project_ix = -1
    @project_cols = %i[name owner]
    @project_col = 0

    # Project details
    @project = nil

    # Active owner (when set, adds owner's projects to @projects)
    @owner_user = nil # Cached user object
    @owner_email = nil # Cached email for guests
    @owner_landing_page = nil # Cached landing page for guests
    @owner_token = nil # Cached session token for user

    # Track which projects were rendering last poll
    @rendering_project_ids = Set.new

    ################ STATE ################

    # Initialize Curses
    init_screen
    start_color
    use_default_colors
    curs_set(0)
    noecho
    stdscr.timeout = 1000

    init_pair(GREEN, COLOR_GREEN, -1)
    init_pair(BLUE, COLOR_BLUE, -1)
    init_pair(YELLOW, COLOR_YELLOW, -1)
    init_pair(RED, COLOR_RED, -1)
    init_pair(GRAY, COLOR_BLACK + 8, -1)
  end

  def start_polling_data
    @data_poll_thread = Thread.new do
      loop do
        begin
          log("Polling data...")

          # Check if an owner is active
          owner_user = nil
          owner_email = nil
          @data_lock.synchronize do
            owner_user = @owner_user
            owner_email = @owner_email
          end

          log("Polling latest #{PROJECT_POLL_COUNT} projects...")
          recent_projects = Project.unscoped
            .includes(
              { upload: :user },
              { blend_checks: :workflow },
              { benchmarks: :workflow },
              { renders: :workflow },
              { order_items: :order },
            )
            .order(stage_updated_at: :desc)
            .first(PROJECT_POLL_COUNT)
            .to_a

          # If owner is active, also load their projects and merge
          if owner_user.present?
            log("Polling latest #{PROJECT_POLL_COUNT} + owner projects for user"\
              " #{owner_user.id}...")
            owner_projects = owner_user.projects
              .includes(
                { upload: :user },
                { renders: :workflow },
                { order_items: :order },
              )
              .first(12)
              .to_a
            projects = (recent_projects + owner_projects).uniq
          elsif owner_email.present?
            log("Polling latest #{PROJECT_POLL_COUNT} + owner projects for guest "\
              "#{owner_email}...")
            owner_projects = Project
              .includes({ upload: :user }, { renders: :workflow })
              .joins(:upload)
              .where(upload: { guest_email_address: owner_email })
              .first(12)
              .to_a
            projects = (recent_projects + owner_projects).uniq
          else
            projects = recent_projects
          end

          current_rendering_ids = projects.select(&:rendering?).map(&:id).to_set
          new_rendering_projects = projects.select do |p|
            p.rendering? && !@rendering_project_ids.include?(p.id)
          end
          announce_new_renders(new_rendering_projects)
          @rendering_project_ids = current_rendering_ids

          render_revenue_24h = Order
            .where(created_at: 24.hours.ago..)
            .where.not(stripe_payment_intent_id: nil).sum(:cash_cents)
          topup_revenue_24h = CreditEntry
            .where(created_at: 24.hours.ago..)
            .where(reason: :topup).sum(:amount_cents)
          refunds_24h = Refund
            .where(created_at: 24.hours.ago..)
            .where.not(stripe_refund_id: nil)
            .sum(:amount_cents)
          revenue_24h = render_revenue_24h + topup_revenue_24h - refunds_24h
          render_revenue_7d = Order
            .where(created_at: 7.days.ago..)
            .where.not(stripe_payment_intent_id: nil).sum(:cash_cents)
          topup_revenue_7d = CreditEntry
            .where(created_at: 7.days.ago..)
            .where(reason: :topup).sum(:amount_cents)
          refunds_7d = Refund
            .where(created_at: 7.days.ago..)
            .where.not(stripe_refund_id: nil)
            .sum(:amount_cents)
          revenue_7d = render_revenue_7d + topup_revenue_7d - refunds_7d
          render_revenue_30d = Order
            .where(created_at: 30.days.ago..)
            .where.not(stripe_payment_intent_id: nil).sum(:cash_cents)
          topup_revenue_30d = CreditEntry
            .where(created_at: 30.days.ago..)
            .where(reason: :topup).sum(:amount_cents)
          refunds_30d = Refund
            .where(created_at: 30.days.ago..)
            .where.not(stripe_refund_id: nil)
            .sum(:amount_cents)
          revenue_30d = render_revenue_30d + topup_revenue_30d - refunds_30d

          @data_lock.synchronize do
            @projects = projects
            @revenue_24h = revenue_24h
            @revenue_7d = revenue_7d
            @revenue_30d = revenue_30d
            @fetch_error = nil
          end
          log("Polled #{projects.length} projects")
        rescue => e
          @data_lock.synchronize do
            @fetch_error = e.message
          end
          log("Error fetching projects: #{e.message}")
        end

        @data_lock.synchronize do
          @poll_signal.wait(@data_lock, 20)
        end
      end
    end
    @data_poll_thread.abort_on_exception = true
  end

  def trigger_poll
    @data_lock.synchronize do
      @poll_signal.signal
    end
  end

  def filtered_owner_projects
    # Filter projects list for active owner (must be called under @data_lock)
    if @owner_user.present?
      @projects.select { |p| p.user == @owner_user }
    elsif @owner_email.present?
      @projects.select { |p| p.upload.guest_email_address == @owner_email }
    else
      []
    end
  end

  def start_display_loop
    begin
      loop do
        render_view

        refresh # What's in memory will be displayed

        ch = getch
        case ch
        when 'h' # Left
          if @view == :home_view
            @project_col -= 1
            @project_col = 0 if @project_col >= @project_cols.length
          end

        when 'l' # Right
          if @view == :home_view
            @project_col += 1
            @project_col = @project_cols.length - 1 if @project_col < 0
          end

        when 'j' # Down
          case @view
          when :home_view
            @project_ix += 1
            @project_ix = 0 if @project_ix >= @projects.length
          when :owner_details
            @data_lock.synchronize do
              owner_projects = filtered_owner_projects
              @project_ix += 1
              @project_ix = 0 if @project_ix >= owner_projects.length
            end
          end

        when 'k' # Up
          case @view
          when :home_view
            @project_ix -= 1
            @project_ix = @projects.length - 1 if @project_ix < 0
          when :owner_details
            @data_lock.synchronize do
              owner_projects = filtered_owner_projects
              @project_ix -= 1
              @project_ix = owner_projects.length - 1 if @project_ix < 0
            end
          end

        # Download project files
        when 'd'
          maybe_download_project

        when 10 # Enter
          maybe_change_view

        when 27 # Escape
          maybe_go_back

        when 'q' then exit 0

        end
      end
    ensure
      close_screen
    end
  end

  private

  def render_view
    case @view
    when :home_view then render_home_view
    when :project_details then render_project_details
    when :owner_details then render_owner_details
    else
      log("Unknown view: #{@view}")
      raise "Unknown view: #{@view}"
    end
  end

  def maybe_change_view
    case @view
    when :home_view
      # Figure out what thing was "clicked"
      if @project_ix >= 0
        case @project_cols[@project_col]
        when :name
          @project = @projects[@project_ix]
          change_view :project_details
        when :owner
          # Set active owner and trigger poll for their projects
          load_owner_data(@projects[@project_ix])
          change_view :owner_details
        end
      end

    when :owner_details
      if @project_ix >= 0
        @data_lock.synchronize do
          owner_projects = filtered_owner_projects
          @project = owner_projects[@project_ix]
        end
        change_view :project_details
      end
    end
  end

  def maybe_go_back
    if @view == :home_view
      @project_ix = -1
    else
      change_view :home_view
    end
  end

  def maybe_download_project
    case @view
    when :home_view
      download_project(@projects[@project_ix]) if @project_ix >= 0
    when :owner_details
      download_project(filtered_owner_projects[@project_ix]) if @project_ix >= 0
    when :project_details
      download_project(@project) if @project.present?
    end
  end

  def download_project(project)
    Thread.new do
      log("Start downloading project '#{project.name}'")
      src = "s3://#{project.bucket_name}/projects/#{project.uuid}/"
      dst = Pathname(Dir.home) / "Downloads" / "#{project.name}-#{project.uuid}"
      `aws s3 sync #{src} '#{dst}'`
      src = "s3://#{project.bucket_name}/uploads/#{project.upload.uuid}/"
      dst /= "upload"
      `aws s3 sync #{src} '#{dst}'`
      log("Finished downloading project '#{project.name}'")
    end
  end

  def change_view(new_view)
    return if @view == new_view
    log("Changing view from #{@view} to #{new_view}")

    # Clear owner data when leaving owner view
    if @view == :owner_details && new_view != :owner_details
      @data_lock.synchronize do
        @owner_user = nil
        @owner_email = nil
        @owner_token = nil
      end
    end

    clear
    @view = new_view
  end

  def load_owner_data(project)
    # Set owner info - projects list already contains matching projects
    @data_lock.synchronize do
      if project.user.present?
        @owner_user = project.user
        @owner_email = nil
        @owner_landing_page = project.user&.page_variant&.landing_page&.slug
        @owner_token = @owner_user.generate_token_for(:session)
      else
        @owner_user = nil
        @owner_email = project.upload.guest_email_address
        @owner_token = nil
      end
    end

    # Trigger poll to load full owner projects and merge into @projects
    trigger_poll
  end

  def render_home_view
    setpos(1, 2)
    attron(A_UNDERLINE)
    render_cell("Projects", 64, [ color_pair(GREEN), A_UNDERLINE ])
    attroff(A_UNDERLINE)
    setpos(3, 2)

    projects = []
    revenue_24h = 0
    revenue_7d = 0
    revenue_30d = 0
    @data_lock.synchronize do
      if @fetch_error
        log("Error fetching projects: #{@fetch_error}")
        render_cell("Error: #{@fetch_error}", 64, color_pair(RED))
      else
        projects = @projects
        revenue_24h = @revenue_24h
        revenue_7d = @revenue_7d
        revenue_30d = @revenue_30d
      end
    end

    projects.first(PROJECT_POLL_COUNT).each_with_index do |p, i|
      hl = @project_cols[@project_col] == :name && i == @project_ix
      render_cell(p.name, 32, [
        p.deleted_at.present? ? color_pair(GRAY) : color_pair(BLUE),
        A_STANDOUT => hl,
      ])
      addstr(" ")

      render_cell(status_str(p), 16, [
        color_pair(GREEN) => p.rendered?,
        color_pair(YELLOW) => p.in_progress? && !p.deleted_at.present?,
        color_pair(RED) => p.failed?,
      ])
      addstr(" ")

      time_ago_str = "#{human_duration(Time.current - p.stage_updated_at)} ago"
      render_cell(time_ago_str, 12)
      addstr(" ")

      not_paid = p.order&.stripe_payment_intent_id.blank?
      render_cell(cents_to_dollars(p.price_cents).rjust(12), 12, [
        color_pair(GRAY) => not_paid,
      ])
      addstr(" ")

      hl = @project_cols[@project_col] == :owner && i == @project_ix
      render_cell(p.owner, 32, [ color_pair(BLUE), A_STANDOUT => hl ])

      setpos(stdscr.cury + 1, 2)
    end

    setpos(stdscr.cury + 1, 2)
    render_cell("24h revenue:", 14, color_pair(YELLOW))
    render_cell(cents_to_dollars(revenue_24h).rjust(12), 12)
    setpos(stdscr.cury + 1, 2)
    render_cell(" 7d revenue:", 14, color_pair(YELLOW))
    render_cell(cents_to_dollars(revenue_7d).rjust(12), 12)
    setpos(stdscr.cury + 1, 2)
    render_cell("30d revenue:", 14, color_pair(YELLOW))
    render_cell(cents_to_dollars(revenue_30d).rjust(12), 12)
  end

  def render_project_details
    first_col_width = 12
    row = 0
    setpos(row += 1, 2)
    render_cell("#{@project.name}", 64, [ color_pair(GREEN), A_UNDERLINE ])
    setpos(row += 2, 2)

    render_cell("ID:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    render_cell(@project.id, 24)
    setpos(row += 1, 2)

    render_cell("UUID:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    render_cell(@project.uuid, 36)
    setpos(row += 1, 2)

    render_cell("Status:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    render_cell(status_str(@project), 16)

    if @project.rendering? && @project.tweaks["deadline_hours"].present?
      setpos(row += 1, 2)
      deadline_at = @project.render.created_at + @project.tweaks["deadline_hours"].hours
      remaining = deadline_at - Time.current
      render_cell("Remaining:", first_col_width, color_pair(YELLOW))
      addstr(" ")
      render_cell(human_duration(remaining), 16)
    end

    setpos(row += 2, 2)

    render_cell("Frames:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    if @project.frame_range_type == "animation"
      frame_str = "#{@project.frame_range_start}-#{@project.frame_range_end}"
      if @project.frame_range_step > 1
        frame_str += " step: #{@project.frame_range_step}"
      end
      frame_str += " (#{@project.frames&.count})"
    else
      frame_str = "#{@project.frame_range_start}"
    end
    render_cell("#{frame_str}", 32)

    setpos(row += 1, 2)

    render_cell("Resolution:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    res_str = "#{@project.resolution_x}x#{@project.resolution_y}"
    scale_str = "@#{@project.resolution_percentage}%"
    if @project.tweaks &&
      @project.tweaks["resolution_percentage"] != @project.resolution_percentage
      scale_str += " -> #{@project.tweaks["resolution_percentage"]}%"
    end
    render_cell("#{res_str} #{scale_str}", 32)

    setpos(row += 1, 2)
    render_cell("Samples:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    spp_str = "#{@project.sampling_max_samples}"
    if @project.tweaks &&
      @project.tweaks["sampling_max_samples"] != @project.sampling_max_samples
      spp_str += " -> #{@project.tweaks["sampling_max_samples"]}"
    end
    render_cell(spp_str, 32)

    if @project.tweaks
      setpos(row += 1, 2)
      render_cell("Deadline:", first_col_width, color_pair(YELLOW))
      addstr(" ")
      render_cell("#{@project.tweaks["deadline_hours"]}h", 32)
    end

    setpos(row += 1, 2)

    if @project.blend_check&.workflow.present?
      setpos(row += 1, 2)
      workflow = @project.blend_check.workflow
      render_cell("Blend check:", first_col_width, color_pair(YELLOW))
      addstr(" ")
      render_cell(human_duration(workflow.updated_at - workflow.created_at), 8)
      addstr(" ")
      render_cell(workflow.uuid, 36, color_pair(GRAY))
    end

    if @project.benchmark&.workflow.present?
      setpos(row += 1, 2)
      workflow = @project.benchmark.workflow
      render_cell("Benchmark:", first_col_width, color_pair(YELLOW))
      addstr(" ")
      render_cell(human_duration(workflow.updated_at - workflow.created_at), 8)
      addstr(" ")
      render_cell(workflow.uuid, 36, color_pair(GRAY))
    end

    if @project.render&.workflow.present?
      setpos(row += 1, 2)
      workflow = @project.render.workflow
      render_cell("Render:", first_col_width, color_pair(YELLOW))
      addstr(" ")
      render_cell(human_duration(workflow.updated_at - workflow.created_at), 8)
      addstr(" ")
      render_cell(workflow.uuid, 36, color_pair(GRAY))
    end
  end

  def render_owner_details
    owner_user = nil
    owner_email = nil
    owner_landing_page = nil
    owner_token = nil
    owner_projects = []
    @data_lock.synchronize do
      owner_user = @owner_user
      owner_email = @owner_email
      owner_landing_page = @owner_landing_page
      owner_token = @owner_token
      owner_projects = filtered_owner_projects
    end

    if owner_user.present?
      render_user_details(owner_user, owner_projects, owner_landing_page, owner_token)
    else
      render_guest_details(owner_email, owner_projects)
    end
  end

  def render_user_details(owner_user, owner_projects, owner_landing_page, owner_token)
    first_col_width = 12
    row = 0
    setpos(row += 1, 2)
    render_cell(
      owner_user.name || owner_user.email_address,
      32,
      [ color_pair(GREEN), A_UNDERLINE ]
    )
    setpos(row += 2, 2)

    render_cell("ID:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    render_cell(owner_user.id, 24)
    setpos(row += 1, 2)

    render_cell("Email:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    render_cell(owner_user.email_address, 48)
    setpos(row += 1, 2)

    render_cell("Credit:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    render_cell(cents_to_dollars(owner_user.render_credit_cents), 24)
    setpos(row += 1, 2)

    render_cell("Landing page:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    render_cell(owner_landing_page, 24)
    setpos(row += 1, 2)

    render_cell("View as:", first_col_width, color_pair(YELLOW))
    addstr(" ")
    render_cell(
      app.root_url(session_token: owner_token),
      256,
      color_pair(YELLOW),
    )
    setpos(row += 2, 2)

    render_owner_projects_table(owner_projects)
  end

  def render_guest_details(owner_email, owner_projects)
    setpos(1, 2)
    render_cell(
      "Guest #{owner_email}",
      64,
      [ color_pair(GREEN), A_UNDERLINE ]
    )
    setpos(3, 2)

    render_owner_projects_table(owner_projects)
  end

  def render_owner_projects_table(owner_projects)
    owner_projects.each_with_index do |p, i|
      # Highlight the selected project name
      hl = i == @project_ix
      render_cell(p.name, 32, [ color_pair(BLUE), A_STANDOUT => hl ])
      addstr(" ")

      # Status
      render_cell(status_str(p), 16, [
        color_pair(GREEN) => p.rendered?,
        color_pair(YELLOW) => p.in_progress?,
        color_pair(RED) => p.failed?,
      ])
      addstr(" ")

      # Update time
      time_ago_str = "#{human_duration(Time.current - p.stage_updated_at)} ago"
      render_cell(time_ago_str, 12)
      addstr(" ")

      # Price
      price_str = cents_to_dollars(p.price_cents)
      render_cell(price_str.rjust(12), 12)
      addstr(" ")

      # No owner column since all projects belong to the same owner

      # Move to the next line beginning
      setpos(stdscr.cury + 1, 2)
    end
  end

  def render_cell(str, width, attrs = [])
    str = truncate(str, width)
    attrs = Array(attrs).flat_map do |attr|
      attr.is_a?(Hash) ? attr.select { |k, v| v } .keys : attr
    end

    attrs.each { |attr| attron(attr) }
    addstr(str)
    attrs.each { |attr| attroff(attr) }

    addstr(" " * (width - str.length))
  end

  def app
    @app ||= Rails.application.routes.url_helpers
  end
end

# Helpers
def announce_new_renders(projects)
  total_cents = projects.sum(:price_cents)

  return if total_cents < NEW_RENDER_CENTS_THRESHOLD

  dollars = cents_to_dollars(total_cents)

  if projects.one?
    project = projects.first
    msg = "#{project.user.first_name} just started rendering '#{project.name}' for " \
      "#{dollars}. It should be finished in #{project.tweaks_deadline_hours} hours."
  else
    deadline_hours_min = projects.map(&:tweaks_deadline_hours).min
    deadline_hours_max = projects.map(&:tweaks_deadline_hours).max

    users = projects.map(&:user).uniq
    if users.one?
      user_str = users.first.first_name
    else
      user_str = "#{users.count} users"
    end

    if deadline_hours_min == deadline_hours_max
      deadline_range = "in #{deadline_hours_min} hours"
    else
      deadline_range = "between #{deadline_hours_min} and #{deadline_hours_max} hours"
    end

    msg = "#{user_str} just started rendering #{projects.count} projects for " \
      "#{dollars}. They should be finished #{deadline_range}."
  end

  log("Announcing: '#{msg}'")
  Thread.new { system("say", msg) }
end

def truncate(str, length)
  str = str.to_s
  return str if str.length <= length
  str[0, length - 1] + "â€¦"
end

def cents_to_dollars(cents)
  return "" if cents.blank?
  "$#{"%.2f" % cents.fdiv(100)}"
end

def status_str(project)
  case project.status
  when "rendering"
    "rendering %5.1f%%" % (project.render.workflow.progress_permil || 0).fdiv(10)
  # when "cancelled"
  #   "cancelled @%5.1f%%" % (project.render.workflow.progress_permil || 0).fdiv(10)
  else
    project.status
  end
end

def human_duration(duration)
  return "" if duration.blank?

  sign = duration < 0 ? "-" : ""

  ms = duration.in_milliseconds.round.abs
  seconds, ms = ms.divmod(1000)
  minutes, seconds = seconds.divmod(60)
  hours, minutes = minutes.divmod(60)
  if hours > 48 then days, hours = hours.divmod(24) else days = 0 end

  return "#{sign}#{days} days" if days > 1
  return "#{sign}#{hours}h" if hours > 23
  return "#{sign}#{hours}:%02dh" % minutes if hours.positive?
  return "#{sign}#{minutes}:%02dm" % seconds if minutes.positive?
  return "#{sign}#{seconds}s" if seconds > 9
  return "#{sign}%.01fs" % (seconds + ms.fdiv(1000)) if seconds > 0

  "#{sign}#{seconds}.%03ds" % ms
end

def log(msg)
  DEBUG_LOG.puts "[#{Time.now}] #{msg}"
  DEBUG_LOG.flush
end

dash = Dashboard.new
dash.start_polling_data
dash.start_display_loop
