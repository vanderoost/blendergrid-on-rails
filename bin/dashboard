#!/usr/bin/env ruby
require_relative "../config/application"

Rails.application.initialize!

require "curses"
include Curses

# Helpers
def truncate(str, length)
  return str if str.length <= length
  str[0, length - 1] + "â€¦"
end

# Debug logging to file
LOG_FILE = Rails.root.join("log", "dashboard.log")
DEBUG_LOG = File.open(LOG_FILE, "a")
def log(msg)
  DEBUG_LOG.puts "[#{Time.now}] #{msg}"
  DEBUG_LOG.flush
end

# Grab data we want to display

@projects = []
@data_lock = Mutex.new
@fetch_error = nil

# Background fetcher
data_thread = Thread.new do
  loop do
    begin
      fresh_data = Project.first(10)
      @data_lock.synchronize do
        @projects = fresh_data
        @fetch_error = nil
      end
      log("Fetched #{fresh_data.length} projects")
    rescue => e
      @data_lock.synchronize do
        @fetch_error = e.message
      end
      log("Error fetching projects: #{e.message}")
    end
    sleep 5
  end
end
data_thread.abort_on_exception = true

# Project formatting (update column widths when projects change)
selectable_cols = %i[name owner]
selected_col = 0
selected_row = -1

# Initialize Curses
init_screen
start_color
use_default_colors
curs_set(0)
noecho
stdscr.timeout = 1000

# Curses colors
GREEN = 1
BLUE = 2
init_pair(GREEN, COLOR_GREEN, -1)
init_pair(BLUE, COLOR_BLUE, -1)

# Main display loopl
begin
  loop do
    # PROJECTS TABLE
    setpos(1, 2)
    attron(A_UNDERLINE)
    addstr("Projects")
    attroff(A_UNDERLINE)
    setpos(3, 2)

    # Calculate column widths
    start_x = 2
    name_width = 30

    @data_lock.synchronize do
      if @fetch_error
        log("Error fetching projects: #{@fetch_error}")
        setpos(1, 2)
        addstr("Error: #{@fetch_error}".ljust(cols - 4, ' '))
      else
        log("Displaying #{@projects.length} projects")
        @projects.each_with_index do |p, i|
          # Highlight the selected project name
          name = truncate(p.name, name_width - 1)
          hl = selectable_cols[selected_col] == :name && i == selected_row
          attron(color_pair(BLUE))
          attron(A_REVERSE) if hl
          addstr(name)
          attroff(A_REVERSE) if hl
          setpos(stdscr.cury, start_x + name_width)
          attroff(color_pair(BLUE))

          # Status
          addstr(p.status.ljust(12))

          # Price
          price_str = p.price_cents ? "$#{p.price_cents&.fdiv(100)}" : ""
          addstr(price_str.rjust(10) + " ")

          # Owner
          hl = selectable_cols[selected_col] == :owner && i == selected_row
          attron(color_pair(GREEN))
          attron(A_REVERSE) if hl
          addstr(p.owner.ljust(16))
          attroff(A_REVERSE) if hl
          attroff(color_pair(GREEN))

          # Move to the next line
          y = stdscr.cury
          setpos(y + 1, 2)
        end
      end
    end

    refresh # What's in memory will be displayed

    # Get input
    case getch
    when 'h'
      selected_col += 1
      selected_col = 0 if selected_col >= selectable_cols.length
    when 'l'
      selected_col -= 1
      selected_col = selectable_cols.length - 1 if selected_col < 0
    when 'j'
      selected_row += 1
      selected_row = 0 if selected_row >= @projects.length
    when 'k'
      selected_row -= 1
      selected_row = @projects.length - 1 if selected_row < 0
    when 27 # Escape
      selected_row = -1
    when 'q' then exit 0
    end
  end
ensure
  close_screen
end
